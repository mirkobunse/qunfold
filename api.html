

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API &mdash; qunfold 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=d45e8c67"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Developer guide" href="developer-guide.html" />
    <link rel="prev" title="Quickstart" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            qunfold
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Quickstart</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#qunfold.AbstractMethod"><code class="docutils literal notranslate"><span class="pre">AbstractMethod</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.AbstractMethod.fit"><code class="docutils literal notranslate"><span class="pre">AbstractMethod.fit()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.AbstractMethod.predict"><code class="docutils literal notranslate"><span class="pre">AbstractMethod.predict()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#qunfold.LinearMethod"><code class="docutils literal notranslate"><span class="pre">LinearMethod</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.LinearMethod.fit"><code class="docutils literal notranslate"><span class="pre">LinearMethod.fit()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.LinearMethod.predict"><code class="docutils literal notranslate"><span class="pre">LinearMethod.predict()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.LinearMethod.solve"><code class="docutils literal notranslate"><span class="pre">LinearMethod.solve()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#popular-algorithms">Popular algorithms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#classify-and-count">Classify and count</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.ACC"><code class="docutils literal notranslate"><span class="pre">ACC</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.PACC"><code class="docutils literal notranslate"><span class="pre">PACC</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#distribution-matching">Distribution matching</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.EDx"><code class="docutils literal notranslate"><span class="pre">EDx</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.EDy"><code class="docutils literal notranslate"><span class="pre">EDy</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.HDx"><code class="docutils literal notranslate"><span class="pre">HDx</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.HDy"><code class="docutils literal notranslate"><span class="pre">HDy</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.KMM"><code class="docutils literal notranslate"><span class="pre">KMM</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#unfolding">Unfolding</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.RUN"><code class="docutils literal notranslate"><span class="pre">RUN</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#methods-beyond-systems-of-linear-equations">Methods beyond systems of linear equations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.LikelihoodMaximizer"><code class="docutils literal notranslate"><span class="pre">LikelihoodMaximizer</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.ExpectationMaximizer"><code class="docutils literal notranslate"><span class="pre">ExpectationMaximizer</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#losses">Losses</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.LeastSquaresLoss"><code class="docutils literal notranslate"><span class="pre">LeastSquaresLoss</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.EnergyLoss"><code class="docutils literal notranslate"><span class="pre">EnergyLoss</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.HellingerSurrogateLoss"><code class="docutils literal notranslate"><span class="pre">HellingerSurrogateLoss</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.BlobelLoss"><code class="docutils literal notranslate"><span class="pre">BlobelLoss</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.CombinedLoss"><code class="docutils literal notranslate"><span class="pre">CombinedLoss</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#regularizers">Regularizers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.TikhonovRegularized"><code class="docutils literal notranslate"><span class="pre">TikhonovRegularized()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.TikhonovRegularization"><code class="docutils literal notranslate"><span class="pre">TikhonovRegularization</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#data-representations">Data representations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.ClassRepresentation"><code class="docutils literal notranslate"><span class="pre">ClassRepresentation</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.DistanceRepresentation"><code class="docutils literal notranslate"><span class="pre">DistanceRepresentation</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.HistogramRepresentation"><code class="docutils literal notranslate"><span class="pre">HistogramRepresentation</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.EnergyKernelRepresentation"><code class="docutils literal notranslate"><span class="pre">EnergyKernelRepresentation</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.GaussianKernelRepresentation"><code class="docutils literal notranslate"><span class="pre">GaussianKernelRepresentation</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.LaplacianKernelRepresentation"><code class="docutils literal notranslate"><span class="pre">LaplacianKernelRepresentation</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.GaussianRFFKernelRepresentation"><code class="docutils literal notranslate"><span class="pre">GaussianRFFKernelRepresentation</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.OriginalRepresentation"><code class="docutils literal notranslate"><span class="pre">OriginalRepresentation</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#utilities">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quapy">QuaPy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.quapy.QuaPyWrapper"><code class="docutils literal notranslate"><span class="pre">QuaPyWrapper</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#cross-validated-training">Cross-validated training</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.sklearn.CVClassifier"><code class="docutils literal notranslate"><span class="pre">CVClassifier</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="developer-guide.html">Developer guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="experiments.html">Experiments</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">qunfold</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">API</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/api.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="api">
<h1>API<a class="headerlink" href="#api" title="Link to this heading"></a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">AbstractMethod</span></code> defines the interface of all quantification and unfolding algorithms. Most importantly, this interface consists of their <code class="docutils literal notranslate"><span class="pre">fit</span></code> and <code class="docutils literal notranslate"><span class="pre">predict</span></code> methods.</p>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.AbstractMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">AbstractMethod</span></span><a class="headerlink" href="#qunfold.AbstractMethod" title="Link to this definition"></a></dt>
<dd><p>Abstract base class for quantification methods.</p>
<dl class="py method">
<dt class="sig sig-object py" id="qunfold.AbstractMethod.fit">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.AbstractMethod.fit" title="Link to this definition"></a></dt>
<dd><p>Fit this quantifier to data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – The feature matrix to which this quantifier will be fitted.</p></li>
<li><p><strong>y</strong> – The labels to which this quantifier will be fitted.</p></li>
<li><p><strong>n_classes</strong> (<em>optional</em>) – The number of expected classes. Defaults to <cite>None</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>This fitted quantifier itself.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qunfold.AbstractMethod.predict">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.AbstractMethod.predict" title="Link to this definition"></a></dt>
<dd><p>Predict the class prevalences in a data set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> – The feature matrix for which this quantifier will make a prediction.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A numpy array of class prevalences.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Instances of many <a class="reference internal" href="#popular-algorithms"><span class="std std-ref">Popular algorithms</span></a> for quantification and unfolding are created through the corresponding constructors. However, you can also define your own quantification method as a <code class="docutils literal notranslate"><span class="pre">LinearMethod</span></code> that combines an arbitrary choice of <a class="reference internal" href="#losses"><span class="std std-ref">Losses</span></a>, <a class="reference internal" href="#regularizers"><span class="std std-ref">Regularizers</span></a> and <a class="reference internal" href="#data-representations"><span class="std std-ref">Data representations</span></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.LinearMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">LinearMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loss:</span> <span class="pre">~qunfold.methods.linear.losses.AbstractLoss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">representation:</span> <span class="pre">~qunfold.methods.linear.representations.AbstractRepresentation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver:</span> <span class="pre">str</span> <span class="pre">=</span> <span class="pre">'trust-ncg'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_options:</span> <span class="pre">~typing.Dict[str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">~typing.Any]</span> <span class="pre">=</span> <span class="pre">&lt;factory&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed:</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.LinearMethod" title="Link to this definition"></a></dt>
<dd><p>A generic quantification / unfolding method that predicts class prevalences by solving a system of linear equations.</p>
<p>This class represents any method that consists of a loss function, a data representation, and a regularization term. In this implementation, any regularized loss is minimized through unconstrained second-order minimization. Valid probability estimates are ensured through a soft-max trick by Bunse (2022).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loss</strong> – An instance from <cite>qunfold.methods.linear.losses</cite>.</p></li>
<li><p><strong>representation</strong> – An instance from <cite>qunfold.methods.linear.representations</cite>.</p></li>
<li><p><strong>solver</strong> (<em>optional</em>) – The <cite>method</cite> argument in <cite>scipy.optimize.minimize</cite>. Defaults to <cite>“trust-ncg”</cite>.</p></li>
<li><p><strong>solver_options</strong> (<em>optional</em>) – The <cite>options</cite> argument in <cite>scipy.optimize.minimize</cite>. Defaults to <cite>{“gtol”: 1e-8, “maxiter”: 1000}</cite>.</p></li>
<li><p><strong>seed</strong> (<em>optional</em>) – A random number generator seed from which a numpy RandomState is created. Defaults to <cite>None</cite>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Here, we create the ordinal variant of ACC (Bunse et al., 2023). This variant consists of the original data representation of ACC and of the original loss of ACC, the latter of which is regularized towards smooth solutions.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">LinearMethod</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">TikhonovRegularized</span><span class="p">(</span><span class="n">LeastSquaresLoss</span><span class="p">(),</span> <span class="mf">0.01</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">ClassRepresentation</span><span class="p">(</span><span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">oob_score</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="qunfold.LinearMethod.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.LinearMethod.fit" title="Link to this definition"></a></dt>
<dd><p>Fit this quantifier to data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – The feature matrix to which this quantifier will be fitted.</p></li>
<li><p><strong>y</strong> – The labels to which this quantifier will be fitted.</p></li>
<li><p><strong>n_classes</strong> (<em>optional</em>) – The number of expected classes. Defaults to <cite>None</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>This fitted quantifier itself.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qunfold.LinearMethod.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.LinearMethod.predict" title="Link to this definition"></a></dt>
<dd><p>Predict the class prevalences in a data set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> – The feature matrix for which this quantifier will make a prediction.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A numpy array of class prevalences.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qunfold.LinearMethod.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.LinearMethod.solve" title="Link to this definition"></a></dt>
<dd><p>Solve the linear system of equations <cite>q=M*p</cite> for <cite>p</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> – A numpy array.</p></li>
<li><p><strong>M</strong> – A numpy matrix.</p></li>
<li><p><strong>N</strong> – The number of data items that <cite>q</cite> represents. For some losses, this argument is optional.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The solution vector <cite>p</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<section id="popular-algorithms">
<h2>Popular algorithms<a class="headerlink" href="#popular-algorithms" title="Link to this heading"></a></h2>
<p>We categorize existing, well-known quantification and unfolding algorithms into <a class="reference internal" href="#classify-and-count"><span class="std std-ref">Classify and count</span></a> methods, <a class="reference internal" href="#distribution-matching"><span class="std std-ref">Distribution matching</span></a> methods, and <a class="reference internal" href="#unfolding"><span class="std std-ref">Unfolding</span></a> methods. Each of these methods consists of a fixed combination of <a class="reference internal" href="#losses"><span class="std std-ref">Losses</span></a>, <a class="reference internal" href="#regularizers"><span class="std std-ref">Regularizers</span></a>, and <a class="reference internal" href="#data-representations"><span class="std std-ref">Data representations</span></a>.</p>
<section id="classify-and-count">
<h3>Classify and count<a class="headerlink" href="#classify-and-count" title="Link to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.ACC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">ACC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trust-ncg'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'gtol':</span> <span class="pre">1e-08,</span> <span class="pre">'maxiter':</span> <span class="pre">1000}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.ACC" title="Link to this definition"></a></dt>
<dd><p>Adjusted Classify &amp; Count by Forman (2008).</p>
<p>This subclass of <cite>LinearMethod</cite> is instantiated with a <cite>LeastSquaresLoss</cite> and a <cite>ClassRepresentation</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – A classifier that implements the API of scikit-learn.</p></li>
<li><p><strong>fit_classifier</strong> (<em>optional</em>) – Whether to fit the <cite>classifier</cite> when this quantifier is fitted. Defaults to <cite>True</cite>.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments accepted by <cite>LinearMethod</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.PACC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">PACC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trust-ncg'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'gtol':</span> <span class="pre">1e-08,</span> <span class="pre">'maxiter':</span> <span class="pre">1000}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.PACC" title="Link to this definition"></a></dt>
<dd><p>Probabilistic Adjusted Classify &amp; Count by Bella et al. (2010).</p>
<p>This subclass of <cite>LinearMethod</cite> is instantiated with a <cite>LeastSquaresLoss</cite> and a <cite>ClassRepresentation</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – A classifier that implements the API of scikit-learn.</p></li>
<li><p><strong>fit_classifier</strong> (<em>optional</em>) – Whether to fit the <cite>classifier</cite> when this quantifier is fitted. Defaults to <cite>True</cite>.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments accepted by <cite>LinearMethod</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="distribution-matching">
<h3>Distribution matching<a class="headerlink" href="#distribution-matching" title="Link to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.EDx">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">EDx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trust-ncg'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'gtol':</span> <span class="pre">1e-08,</span> <span class="pre">'maxiter':</span> <span class="pre">1000}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.EDx" title="Link to this definition"></a></dt>
<dd><p>The energy distance-based EDx method by Kawakubo et al. (2016).</p>
<p>This subclass of <cite>LinearMethod</cite> is instantiated with an <cite>EnergyLoss</cite> and a <cite>DistanceRepresentation</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>metric</strong> (<em>optional</em>) – The metric with which the distance between data items is measured. Can take any value that is accepted by <cite>scipy.spatial.distance.cdist</cite>. Defaults to <cite>“euclidean”</cite>.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments accepted by <cite>LinearMethod</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.EDy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">EDy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trust-ncg'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'gtol':</span> <span class="pre">1e-08,</span> <span class="pre">'maxiter':</span> <span class="pre">1000}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.EDy" title="Link to this definition"></a></dt>
<dd><p>The energy distance-based EDy method by Castaño et al. (2022).</p>
<p>This subclass of <cite>LinearMethod</cite> is instantiated with an <cite>EnergyLoss</cite> and a <cite>DistanceRepresentation</cite>, the latter of which uses a <cite>ClassRepresentation</cite> as a preprocessor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – A classifier that implements the API of scikit-learn.</p></li>
<li><p><strong>metric</strong> (<em>optional</em>) – The metric with which the distance between data items is measured. Can take any value that is accepted by <cite>scipy.spatial.distance.cdist</cite>. Defaults to <cite>“euclidean”</cite>.</p></li>
<li><p><strong>fit_classifier</strong> (<em>optional</em>) – Whether to fit the <cite>classifier</cite> when this quantifier is fitted. Defaults to <cite>True</cite>.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments accepted by <cite>LinearMethod</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.HDx">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">HDx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_bins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trust-ncg'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'gtol':</span> <span class="pre">1e-08,</span> <span class="pre">'maxiter':</span> <span class="pre">1000}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.HDx" title="Link to this definition"></a></dt>
<dd><p>The Hellinger distance-based HDx method by González-Castro et al. (2013).</p>
<p>This subclass of <cite>LinearMethod</cite> is instantiated with a <cite>HellingerSurrogateLoss</cite> and a <cite>HistogramRepresentation</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_bins</strong> – The number of bins in each feature.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments accepted by <cite>LinearMethod</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.HDy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">HDy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_bins</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trust-ncg'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'gtol':</span> <span class="pre">1e-08,</span> <span class="pre">'maxiter':</span> <span class="pre">1000}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.HDy" title="Link to this definition"></a></dt>
<dd><p>The Hellinger distance-based HDy method by González-Castro et al. (2013).</p>
<p>This subclass of <cite>LinearMethod</cite> is instantiated with a <cite>HellingerSurrogateLoss</cite> and a <cite>HistogramRepresentation</cite>, the latter of which uses a <cite>ClassRepresentation</cite> as a preprocessor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – A classifier that implements the API of scikit-learn.</p></li>
<li><p><strong>n_bins</strong> – The number of bins in each class.</p></li>
<li><p><strong>fit_classifier</strong> (<em>optional</em>) – Whether to fit the <cite>classifier</cite> when this quantifier is fitted. Defaults to <cite>True</cite>.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments accepted by <cite>LinearMethod</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.KMM">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">KMM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'energy'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_rff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trust-ncg'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'gtol':</span> <span class="pre">1e-08,</span> <span class="pre">'maxiter':</span> <span class="pre">1000}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.KMM" title="Link to this definition"></a></dt>
<dd><p>The kernel-based KMM method with random Fourier features by Dussap et al. (2023).</p>
<p>This subclass of <cite>LinearMethod</cite> is instantiated with a <cite>LeastSquaresLoss</cite> and an instance of a <cite>KernelRepresentation</cite> sub-class that corresponds to the <cite>kernel</cite> argument.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kernel</strong> (<em>optional</em>) – Which kernel to use. Can be a callable with the signature <cite>(X[y==i], X[y==j]) -&gt; scalar</cite> or one of “energy”, “gaussian”, “laplacian” and “rff”. Defaults to “energy”.</p></li>
<li><p><strong>sigma</strong> (<em>optional</em>) – A smoothing parameter that is used if <cite>kernel in [“gaussian”, “laplacian”, “rff”]</cite>. Defaults to <cite>1</cite>.</p></li>
<li><p><strong>n_rff</strong> (<em>optional</em>) – The number of random Fourier features if <cite>kernel == “rff”</cite>. Defaults to <cite>1000</cite>.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments accepted by <cite>LinearMethod</cite>. The <cite>seed</cite> argument also controls the randomness of the random Fourier features if <cite>kernel == “rff”</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="unfolding">
<h3>Unfolding<a class="headerlink" href="#unfolding" title="Link to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.RUN">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">RUN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">representation</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trust-ncg'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'gtol':</span> <span class="pre">1e-08,</span> <span class="pre">'maxiter':</span> <span class="pre">1000}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.RUN" title="Link to this definition"></a></dt>
<dd><p>Regularized Unfolding by Blobel (1985).</p>
<p>This subclass of <cite>LinearMethod</cite> is instantiated with a <cite>TikhonovRegularized(BlobelLoss)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>representation</strong> – An instance from <cite>qunfold.methods.linear.representations</cite>.</p></li>
<li><p><strong>tau</strong> (<em>optional</em>) – The regularization strength. Defaults to 0.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments accepted by <cite>LinearMethod</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="methods-beyond-systems-of-linear-equations">
<h3>Methods beyond systems of linear equations<a class="headerlink" href="#methods-beyond-systems-of-linear-equations" title="Link to this heading"></a></h3>
<p>Not all quantification algorithms make predictions by solving systems of linear equations. Instead, the following methods maximize the likelihood of the prediction directly.</p>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.LikelihoodMaximizer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">LikelihoodMaximizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier:</span> <span class="pre">~typing.Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver:</span> <span class="pre">str</span> <span class="pre">=</span> <span class="pre">'trust-ncg'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_options:</span> <span class="pre">~typing.Dict[str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">~typing.Any]</span> <span class="pre">=</span> <span class="pre">&lt;factory&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau_0:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau_1:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed:</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.LikelihoodMaximizer" title="Link to this definition"></a></dt>
<dd><p>The maximum likelihood method, as studied by Alexandari et al. (2020).</p>
<p>This method is proven to be asymptotically equivalent to the <cite>ExpectationMaximizer</cite> by Saerens et al. (2002).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – A classifier that implements the API of scikit-learn.</p></li>
<li><p><strong>solver</strong> (<em>optional</em>) – The <cite>method</cite> argument in <cite>scipy.optimize.minimize</cite>. Defaults to <cite>“trust-ncg”</cite>.</p></li>
<li><p><strong>solver_options</strong> (<em>optional</em>) – The <cite>options</cite> argument in <cite>scipy.optimize.minimize</cite>. Defaults to <cite>{“gtol”: 1e-8, “maxiter”: 1000}</cite>.</p></li>
<li><p><strong>tau_0</strong> (<em>optional</em>) – The regularization strength for penalizing deviations from uniform predictions. Defaults to <cite>0</cite>.</p></li>
<li><p><strong>tau_1</strong> (<em>optional</em>) – The regularization strength for penalizing deviations from non-ordinal predictions. Defaults to <cite>0</cite>.</p></li>
<li><p><strong>fit_classifier</strong> (<em>optional</em>) – Whether to fit the <cite>classifier</cite> when this quantifier is fitted. Defaults to <cite>True</cite>.</p></li>
<li><p><strong>seed</strong> (<em>optional</em>) – A random number generator seed from which a numpy RandomState is created. Defaults to <cite>None</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.ExpectationMaximizer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">ExpectationMaximizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.ExpectationMaximizer" title="Link to this definition"></a></dt>
<dd><p>The expectation maximization-based method by Saerens et al. (2002).</p>
<p>This method is proven to be asymptotically equivalent to the <cite>LikelihoodMaximizer</cite> by Alexandari et al. (2020).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – A classifier that implements the API of scikit-learn.</p></li>
<li><p><strong>max_iter</strong> (<em>optional</em>) – The maximum number of iterations. Defaults to <cite>100</cite>, which is hardly ever reached with the default value of <cite>tol</cite>.</p></li>
<li><p><strong>tol</strong> (<em>optional</em>) – The convergence tolerance for the L2 norm between iterations. Defaults to <cite>1e-6</cite>, the <cite>float32</cite> resolution.</p></li>
<li><p><strong>fit_classifier</strong> (<em>optional</em>) – Whether to fit the <cite>classifier</cite> when this quantifier is fitted. Defaults to <cite>True</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="losses">
<h2>Losses<a class="headerlink" href="#losses" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.LeastSquaresLoss">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">LeastSquaresLoss</span></span><a class="headerlink" href="#qunfold.LeastSquaresLoss" title="Link to this definition"></a></dt>
<dd><p>The loss function of ACC (Forman, 2008), PACC (Bella et al., 2019), and ReadMe (Hopkins &amp; King, 2010).</p>
<p>This loss function computes the sum of squares of element-wise errors between <cite>q</cite> and <cite>M*p</cite>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.EnergyLoss">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">EnergyLoss</span></span><a class="headerlink" href="#qunfold.EnergyLoss" title="Link to this definition"></a></dt>
<dd><p>The loss function of EDx (Kawakubo et al., 2016) and EDy (Castaño et al., 2022).</p>
<p>This loss function represents the Energy Distance between two samples.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.HellingerSurrogateLoss">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">HellingerSurrogateLoss</span></span><a class="headerlink" href="#qunfold.HellingerSurrogateLoss" title="Link to this definition"></a></dt>
<dd><p>The loss function of HDx and HDy (González-Castro et al., 2013).</p>
<p>This loss function computes the average of the squared Hellinger distances between feature-wise (or class-wise) histograms. Note that the original HDx and HDy by González-Castro et al (2013) do not use the squared but the regular Hellinger distance. Their approach is problematic because the regular distance is not always twice differentiable and, hence, complicates numerical optimizations.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.BlobelLoss">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">BlobelLoss</span></span><a class="headerlink" href="#qunfold.BlobelLoss" title="Link to this definition"></a></dt>
<dd><p>The loss function of RUN (Blobel, 1985).</p>
<p>This loss function models a likelihood function under the assumption of independent Poisson-distributed elements of <cite>q</cite> with Poisson rates <cite>M*p</cite>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.CombinedLoss">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">CombinedLoss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">losses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.CombinedLoss" title="Link to this definition"></a></dt>
<dd><p>The weighted sum of multiple losses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*losses</strong> – An arbitrary number of losses to be added together.</p></li>
<li><p><strong>weights</strong> (<em>optional</em>) – An array of weights which the losses are scaled.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">CombinedLoss</span></code> to create arbitrary, weighted sums of losses and regularizers.</p>
</div>
</section>
<section id="regularizers">
<h2>Regularizers<a class="headerlink" href="#regularizers" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="qunfold.TikhonovRegularized">
<span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">TikhonovRegularized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.TikhonovRegularized" title="Link to this definition"></a></dt>
<dd><p>Add TikhonovRegularization (Blobel, 1985) to any loss.</p>
<p>Calling this function is equivalent to calling</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CombinedLoss</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">TikhonovRegularization</span><span class="p">(),</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">tau</span><span class="p">])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loss</strong> – An instance from <cite>qunfold.losses</cite>.</p></li>
<li><p><strong>tau</strong> (<em>optional</em>) – The regularization strength. Defaults to 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of <cite>CombinedLoss</cite>.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The regularized loss of RUN (Blobel, 1985) is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">TikhonovRegularization</span><span class="p">(</span><span class="n">BlobelLoss</span><span class="p">(),</span> <span class="n">tau</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.TikhonovRegularization">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">TikhonovRegularization</span></span><a class="headerlink" href="#qunfold.TikhonovRegularization" title="Link to this definition"></a></dt>
<dd><p>Tikhonov regularization, as proposed by Blobel (1985).</p>
<p>This regularization promotes smooth solutions. This behavior is often required in ordinal quantification and in unfolding problems.</p>
</dd></dl>

</section>
<section id="data-representations">
<h2>Data representations<a class="headerlink" href="#data-representations" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.ClassRepresentation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">ClassRepresentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_probabilistic</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.ClassRepresentation" title="Link to this definition"></a></dt>
<dd><p>A classification-based data representation.</p>
<p>This representation can either be probabilistic (using the posterior predictions of a classifier) or crisp (using the class predictions of a classifier). It is used in ACC, PACC, CC, PCC, and SLD.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – A classifier that implements the API of scikit-learn.</p></li>
<li><p><strong>is_probabilistic</strong> (<em>optional</em>) – Whether probabilistic or crisp predictions of the <cite>classifier</cite> are used to represent the data. Defaults to <cite>False</cite>.</p></li>
<li><p><strong>fit_classifier</strong> (<em>optional</em>) – Whether to fit the <cite>classifier</cite> when this quantifier is fitted. Defaults to <cite>True</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.DistanceRepresentation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">DistanceRepresentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preprocessor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="developer-guide.html#qunfold.methods.linear.representations.AbstractRepresentation" title="qunfold.methods.linear.representations.AbstractRepresentation"><span class="pre">AbstractRepresentation</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.DistanceRepresentation" title="Link to this definition"></a></dt>
<dd><p>A distance-based data representation, as it is used in <cite>EDx</cite> and <cite>EDy</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>metric</strong> (<em>optional</em>) – The metric with which the distance between data items is measured. Can take any value that is accepted by <cite>scipy.spatial.distance.cdist</cite>. Defaults to <cite>“euclidean”</cite>.</p></li>
<li><p><strong>preprocessor</strong> (<em>optional</em>) – Another <cite>AbstractRepresentation</cite> that is called before this representation. Defaults to <cite>None</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.HistogramRepresentation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">HistogramRepresentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_bins</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preprocessor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="developer-guide.html#qunfold.methods.linear.representations.AbstractRepresentation" title="qunfold.methods.linear.representations.AbstractRepresentation"><span class="pre">AbstractRepresentation</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit_scale</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.HistogramRepresentation" title="Link to this definition"></a></dt>
<dd><p>A histogram-based data representation, as it is used in <cite>HDx</cite> and <cite>HDy</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_bins</strong> – The number of bins in each feature.</p></li>
<li><p><strong>preprocessor</strong> (<em>optional</em>) – Another <cite>AbstractRepresentation</cite> that is called before this representation. Defaults to <cite>None</cite>.</p></li>
<li><p><strong>unit_scale</strong> (<em>optional</em>) – Whether or not to scale each output to a sum of one. A value of <cite>False</cite> indicates that the sum of each output is the number of features. Defaults to <cite>True</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.EnergyKernelRepresentation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">EnergyKernelRepresentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">preprocessor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="developer-guide.html#qunfold.methods.linear.representations.AbstractRepresentation" title="qunfold.methods.linear.representations.AbstractRepresentation"><span class="pre">AbstractRepresentation</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.EnergyKernelRepresentation" title="Link to this definition"></a></dt>
<dd><p>A kernel-based data representation, as it is used in <cite>KMM</cite>, that uses the <cite>energy</cite> kernel:</p>
<blockquote>
<div><p>k(x_1, x_2) = ||x_1|| + ||x_2|| - ||x_1 - x_2||</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The methods of this representation do not support setting <cite>average=False</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>preprocessor</strong> (<em>optional</em>) – Another <cite>AbstractRepresentation</cite> that is called before this representation. Defaults to <cite>None</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.GaussianKernelRepresentation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">GaussianKernelRepresentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preprocessor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="developer-guide.html#qunfold.methods.linear.representations.AbstractRepresentation" title="qunfold.methods.linear.representations.AbstractRepresentation"><span class="pre">AbstractRepresentation</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.GaussianKernelRepresentation" title="Link to this definition"></a></dt>
<dd><p>A kernel-based data representation, as it is used in <cite>KMM</cite>, that uses the <cite>gaussian</cite> kernel:</p>
<blockquote>
<div><p>k(x, y) = exp(-||x - y||^2 / (2σ^2))</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma</strong> (<em>optional</em>) – A smoothing parameter of the kernel function. Defaults to <cite>1</cite>.</p></li>
<li><p><strong>preprocessor</strong> (<em>optional</em>) – Another <cite>AbstractRepresentation</cite> that is called before this representation. Defaults to <cite>None</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.LaplacianKernelRepresentation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">LaplacianKernelRepresentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.LaplacianKernelRepresentation" title="Link to this definition"></a></dt>
<dd><p>A kernel-based data representation, as it is used in <cite>KMM</cite>, that uses the <cite>laplacian</cite> kernel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sigma</strong> (<em>optional</em>) – A smoothing parameter of the kernel function. Defaults to <cite>1</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.GaussianRFFKernelRepresentation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">GaussianRFFKernelRepresentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_rff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preprocessor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="developer-guide.html#qunfold.methods.linear.representations.AbstractRepresentation" title="qunfold.methods.linear.representations.AbstractRepresentation"><span class="pre">AbstractRepresentation</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.GaussianRFFKernelRepresentation" title="Link to this definition"></a></dt>
<dd><p>An efficient approximation of the <cite>GaussianKernelRepresentation</cite>, as it is used in <cite>KMM</cite>, using random Fourier features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma</strong> (<em>optional</em>) – A smoothing parameter of the kernel function. Defaults to <cite>1</cite>.</p></li>
<li><p><strong>n_rff</strong> (<em>optional</em>) – The number of random Fourier features. Defaults to <cite>1000</cite>.</p></li>
<li><p><strong>preprocessor</strong> (<em>optional</em>) – Another <cite>AbstractRepresentation</cite> that is called before this representation. Defaults to <cite>None</cite>.</p></li>
<li><p><strong>seed</strong> (<em>optional</em>) – Controls the randomness of the random Fourier features. Defaults to <cite>None</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.OriginalRepresentation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">OriginalRepresentation</span></span><a class="headerlink" href="#qunfold.OriginalRepresentation" title="Link to this definition"></a></dt>
<dd><p>A dummy representation that simply returns the data as it is.</p>
</dd></dl>

</section>
<section id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Link to this heading"></a></h2>
<p>The following classes provide functionalities that go beyond the composition of quantification methods.</p>
<section id="quapy">
<h3>QuaPy<a class="headerlink" href="#quapy" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">qunfold.quapy</span></code> module allows you to wrap any quantification method for being used in <a class="reference external" href="https://github.com/HLT-ISTI/QuaPy">QuaPy</a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.quapy.QuaPyWrapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.quapy.</span></span><span class="sig-name descname"><span class="pre">QuaPyWrapper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">_method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#qunfold.AbstractMethod" title="qunfold.methods.AbstractMethod"><span class="pre">AbstractMethod</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.quapy.QuaPyWrapper" title="Link to this definition"></a></dt>
<dd><p>A thin wrapper for using qunfold methods in QuaPy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>_method</strong> – An instance of <cite>qunfold.methods.AbstractMethod</cite> to wrap.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Here, we wrap an instance of ACC to perform a grid search with QuaPy.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qunfold_method</span> <span class="o">=</span> <span class="n">QuaPyWrapper</span><span class="p">(</span><span class="n">ACC</span><span class="p">(</span><span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">obb_score</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quapy</span><span class="o">.</span><span class="n">model_selection</span><span class="o">.</span><span class="n">GridSearchQ</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">model</span> <span class="o">=</span> <span class="n">qunfold_method</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span> <span class="c1"># try both splitting criteria</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="s2">&quot;representation__classifier__estimator__criterion&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;gini&quot;</span><span class="p">,</span> <span class="s2">&quot;entropy&quot;</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">},</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="c1"># ...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="cross-validated-training">
<h3>Cross-validated training<a class="headerlink" href="#cross-validated-training" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">qunfold.sklearn</span></code> module allows you to train classification-based quantification methods through cross-validation. Importing this module requires <a class="reference external" href="https://scikit-learn.org/stable/">scikit-learn</a> to be installed.</p>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.sklearn.CVClassifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.sklearn.</span></span><span class="sig-name descname"><span class="pre">CVClassifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_estimators</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.sklearn.CVClassifier" title="Link to this definition"></a></dt>
<dd><p>An ensemble of classifiers that are trained from cross-validation folds.</p>
<p>All objects of this type have a fixed attribute <cite>oob_score = True</cite> and, when trained, a fitted attribute <cite>self.oob_decision_function_</cite>, just like scikit-learn bagging classifiers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>estimator</strong> – A classifier that implements the API of scikit-learn.</p></li>
<li><p><strong>n_estimators</strong> (<em>optional</em>) – The number of stratified cross-validation folds. Defaults to <cite>5</cite>.</p></li>
<li><p><strong>random_state</strong> (<em>optional</em>) – The random state for stratification. Defaults to <cite>None</cite>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Here, we create an instance of ACC that trains a logistic regression classifier with 10 cross-validation folds.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ACC</span><span class="p">(</span><span class="n">CVClassifier</span><span class="p">(</span><span class="n">LogisticRegression</span><span class="p">(),</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>If you use a bagging classifier (like random forests) with <code class="docutils literal notranslate"><span class="pre">oob_score=True</span></code>, you do not need to use cross-validation. Instead, the quantification method is then trained on the out-of-bag predictions of the bagging classifier.</p>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Quickstart" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="developer-guide.html" class="btn btn-neutral float-right" title="Developer guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>