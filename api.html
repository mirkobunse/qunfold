<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API &mdash; qunfold 0.0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=f6245a2f"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Developer guide" href="developer-guide.html" />
    <link rel="prev" title="Quickstart" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            qunfold
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Quickstart</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#qunfold.GenericMethod"><code class="docutils literal notranslate"><span class="pre">GenericMethod</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.GenericMethod.fit"><code class="docutils literal notranslate"><span class="pre">GenericMethod.fit()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.GenericMethod.predict"><code class="docutils literal notranslate"><span class="pre">GenericMethod.predict()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.GenericMethod.solve"><code class="docutils literal notranslate"><span class="pre">GenericMethod.solve()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#popular-algorithms">Popular algorithms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#classify-and-count">Classify and count</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.ACC"><code class="docutils literal notranslate"><span class="pre">ACC</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.PACC"><code class="docutils literal notranslate"><span class="pre">PACC</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#distribution-matching">Distribution matching</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.EDx"><code class="docutils literal notranslate"><span class="pre">EDx</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.EDy"><code class="docutils literal notranslate"><span class="pre">EDy</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.HDx"><code class="docutils literal notranslate"><span class="pre">HDx</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.HDy"><code class="docutils literal notranslate"><span class="pre">HDy</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#unfolding">Unfolding</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.RUN"><code class="docutils literal notranslate"><span class="pre">RUN</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#losses">Losses</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.LeastSquaresLoss"><code class="docutils literal notranslate"><span class="pre">LeastSquaresLoss</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.EnergyLoss"><code class="docutils literal notranslate"><span class="pre">EnergyLoss</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.HellingerSurrogateLoss"><code class="docutils literal notranslate"><span class="pre">HellingerSurrogateLoss</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.BlobelLoss"><code class="docutils literal notranslate"><span class="pre">BlobelLoss</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.CombinedLoss"><code class="docutils literal notranslate"><span class="pre">CombinedLoss</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#regularizers">Regularizers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.TikhonovRegularized"><code class="docutils literal notranslate"><span class="pre">TikhonovRegularized()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.TikhonovRegularization"><code class="docutils literal notranslate"><span class="pre">TikhonovRegularization</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#feature-transformations">Feature transformations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.ClassTransformer"><code class="docutils literal notranslate"><span class="pre">ClassTransformer</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.DistanceTransformer"><code class="docutils literal notranslate"><span class="pre">DistanceTransformer</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#qunfold.HistogramTransformer"><code class="docutils literal notranslate"><span class="pre">HistogramTransformer</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#utilities">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quapy">QuaPy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.quapy.QuaPyWrapper"><code class="docutils literal notranslate"><span class="pre">QuaPyWrapper</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#cross-validated-training">Cross-validated training</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qunfold.sklearn.CVClassifier"><code class="docutils literal notranslate"><span class="pre">CVClassifier</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="developer-guide.html">Developer guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="experiments.html">Experiments</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">qunfold</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">API</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/api.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="api">
<h1>API<a class="headerlink" href="#api" title="Permalink to this heading"></a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">GenericMethod</span></code> defines the interface for many common quantification and unfolding algorithms. Most importantly, this interface consists of their <code class="docutils literal notranslate"><span class="pre">fit</span></code> and <code class="docutils literal notranslate"><span class="pre">predict</span></code> methods.</p>
<p>Instances of <a class="reference internal" href="#popular-algorithms"><span class="std std-ref">Popular algorithms</span></a> for quantification and unfolding are created through the corresponding constructors. However, you can also define your own quantification methods as a <code class="docutils literal notranslate"><span class="pre">GenericMethod</span></code> that combines an arbitrary choice of <a class="reference internal" href="#losses"><span class="std std-ref">Losses</span></a>, <a class="reference internal" href="#regularizers"><span class="std std-ref">Regularizers</span></a> and <a class="reference internal" href="#feature-transformations"><span class="std std-ref">Feature transformations</span></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.GenericMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">GenericMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transformer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trust-ncg'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'gtol':</span> <span class="pre">1e-08,</span> <span class="pre">'maxiter':</span> <span class="pre">1000}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.GenericMethod" title="Permalink to this definition"></a></dt>
<dd><p>A generic quantification / unfolding method.</p>
<p>This class represents any method that consists of a loss function, a feature transformation, and a regularization term. In this implementation, any regularized loss is minimized through unconstrained second-order minimization. Valid probability estimates are ensured through a soft-max trick by Bunse (2022).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loss</strong> – An instance from <cite>qunfold.losses</cite>.</p></li>
<li><p><strong>transformer</strong> – An instance from <cite>qunfold.transformers</cite>.</p></li>
<li><p><strong>solver</strong> (<em>optional</em>) – The <cite>method</cite> argument in <cite>scipy.optimize.minimize</cite>. Defaults to <cite>“trust-ncg”</cite>.</p></li>
<li><p><strong>solver_options</strong> (<em>optional</em>) – The <cite>options</cite> argument in <cite>scipy.optimize.minimize</cite>. Defaults to <cite>{“gtol”: 1e-8, “maxiter”: 1000}</cite>.</p></li>
<li><p><strong>seed</strong> (<em>optional</em>) – A random number generator seed from which a numpy RandomState is created. Defaults to <cite>None</cite>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Here, we create the ordinal variant of ACC (Bunse et al., 2023). This variant consists of the original feature transformation of ACC and of the original loss of ACC, the latter of which is regularized towards smooth solutions.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">GenericMethod</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">TikhonovRegularized</span><span class="p">(</span><span class="n">LeastSquaresLoss</span><span class="p">(),</span> <span class="mf">0.01</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">ClassTransformer</span><span class="p">(</span><span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">oob_score</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="qunfold.GenericMethod.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.GenericMethod.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit this quantifier to data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – The feature matrix to which this quantifier will be fitted.</p></li>
<li><p><strong>y</strong> – The labels to which this quantifier will be fitted.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>This fitted quantifier itself.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qunfold.GenericMethod.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.GenericMethod.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict the class prevalences in a data set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> – The feature matrix for which this quantifier will make a prediction.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A numpy array of class prevalences.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qunfold.GenericMethod.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.GenericMethod.solve" title="Permalink to this definition"></a></dt>
<dd><p>Solve the linear system of equations <cite>q=M*p</cite> for <cite>p</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> – A numpy array.</p></li>
<li><p><strong>M</strong> – A numpy matrix.</p></li>
<li><p><strong>N</strong> – The number of data items that <cite>q</cite> represents. For some losses, this argument is optional.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The solution vector <cite>p</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<section id="popular-algorithms">
<h2>Popular algorithms<a class="headerlink" href="#popular-algorithms" title="Permalink to this heading"></a></h2>
<p>We categorize existing, well-known quantification and unfolding algorithms into <a class="reference internal" href="#classify-and-count"><span class="std std-ref">Classify and count</span></a> methods, <a class="reference internal" href="#distribution-matching"><span class="std std-ref">Distribution matching</span></a> methods, and <a class="reference internal" href="#unfolding"><span class="std std-ref">Unfolding</span></a> methods. Each of these methods consists of a fixed combination of <a class="reference internal" href="#losses"><span class="std std-ref">Losses</span></a>, <a class="reference internal" href="#regularizers"><span class="std std-ref">Regularizers</span></a>, and <a class="reference internal" href="#feature-transformations"><span class="std std-ref">Feature transformations</span></a>.</p>
<section id="classify-and-count">
<h3>Classify and count<a class="headerlink" href="#classify-and-count" title="Permalink to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.ACC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">ACC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.ACC" title="Permalink to this definition"></a></dt>
<dd><p>Adjusted Classify &amp; Count by Forman (2008).</p>
<p>This subclass of <cite>GenericMethod</cite> is instantiated with a <cite>LeastSquaresLoss</cite> and a <cite>ClassTransformer</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – A classifier that implements the API of scikit-learn.</p></li>
<li><p><strong>fit_classifier</strong> (<em>optional</em>) – Whether to fit the <cite>classifier</cite> when this quantifier is fitted. Defaults to <cite>True</cite>.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments accepted by <cite>GenericMethod</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.PACC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">PACC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.PACC" title="Permalink to this definition"></a></dt>
<dd><p>Probabilistic Adjusted Classify &amp; Count by Bella et al. (2010).</p>
<p>This subclass of <cite>GenericMethod</cite> is instantiated with a <cite>LeastSquaresLoss</cite> and a <cite>ClassTransformer</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – A classifier that implements the API of scikit-learn.</p></li>
<li><p><strong>fit_classifier</strong> (<em>optional</em>) – Whether to fit the <cite>classifier</cite> when this quantifier is fitted. Defaults to <cite>True</cite>.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments accepted by <cite>GenericMethod</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="distribution-matching">
<h3>Distribution matching<a class="headerlink" href="#distribution-matching" title="Permalink to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.EDx">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">EDx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.EDx" title="Permalink to this definition"></a></dt>
<dd><p>The energy distance-based EDx method by Kawakubo et al. (2016).</p>
<p>This subclass of <cite>GenericMethod</cite> is instantiated with an <cite>EnergyLoss</cite> and a <cite>DistanceTransformer</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>metric</strong> (<em>optional</em>) – The metric with which the distance between data items is measured. Can take any value that is accepted by <cite>scipy.spatial.distance.cdist</cite>. Defaults to <cite>“euclidean”</cite>.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments accepted by <cite>GenericMethod</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.EDy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">EDy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.EDy" title="Permalink to this definition"></a></dt>
<dd><p>The energy distance-based EDy method by Castaño et al. (2022).</p>
<p>This subclass of <cite>GenericMethod</cite> is instantiated with an <cite>EnergyLoss</cite> and a <cite>DistanceTransformer</cite>, the latter of which uses a <cite>ClassTransformer</cite> as a preprocessor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – A classifier that implements the API of scikit-learn.</p></li>
<li><p><strong>metric</strong> (<em>optional</em>) – The metric with which the distance between data items is measured. Can take any value that is accepted by <cite>scipy.spatial.distance.cdist</cite>. Defaults to <cite>“euclidean”</cite>.</p></li>
<li><p><strong>fit_classifier</strong> (<em>optional</em>) – Whether to fit the <cite>classifier</cite> when this quantifier is fitted. Defaults to <cite>True</cite>.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments accepted by <cite>GenericMethod</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.HDx">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">HDx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_bins</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.HDx" title="Permalink to this definition"></a></dt>
<dd><p>The Hellinger distance-based HDx method by González-Castro et al. (2013).</p>
<p>This subclass of <cite>GenericMethod</cite> is instantiated with a <cite>HellingerSurrogateLoss</cite> and a <cite>HistogramTransformer</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_bins</strong> – The number of bins in each feature.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments accepted by <cite>GenericMethod</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.HDy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">HDy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_bins</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.HDy" title="Permalink to this definition"></a></dt>
<dd><p>The Hellinger distance-based HDy method by González-Castro et al. (2013).</p>
<p>This subclass of <cite>GenericMethod</cite> is instantiated with a <cite>HellingerSurrogateLoss</cite> and a <cite>HistogramTransformer</cite>, the latter of which uses a <cite>ClassTransformer</cite> as a preprocessor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – A classifier that implements the API of scikit-learn.</p></li>
<li><p><strong>n_bins</strong> – The number of bins in each class.</p></li>
<li><p><strong>fit_classifier</strong> (<em>optional</em>) – Whether to fit the <cite>classifier</cite> when this quantifier is fitted. Defaults to <cite>True</cite>.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments accepted by <cite>GenericMethod</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="unfolding">
<h3>Unfolding<a class="headerlink" href="#unfolding" title="Permalink to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.RUN">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">RUN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transformer</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.RUN" title="Permalink to this definition"></a></dt>
<dd><p>Regularized Unfolding by Blobel (1985).</p>
<p>This subclass of <cite>GenericMethod</cite> is instantiated with a <cite>TikhonovRegularized(BlobelLoss)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transformer</strong> – An instance from <cite>qunfold.transformers</cite>.</p></li>
<li><p><strong>tau</strong> (<em>optional</em>) – The regularization strength. Defaults to 0.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments accepted by <cite>GenericMethod</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="losses">
<h2>Losses<a class="headerlink" href="#losses" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.LeastSquaresLoss">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">LeastSquaresLoss</span></span><a class="headerlink" href="#qunfold.LeastSquaresLoss" title="Permalink to this definition"></a></dt>
<dd><p>The loss function of ACC (Forman, 2008), PACC (Bella et al., 2019), and ReadMe (Hopkins &amp; King, 2010).</p>
<p>This loss function computes the sum of squares of element-wise errors between <cite>q</cite> and <cite>M*p</cite>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.EnergyLoss">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">EnergyLoss</span></span><a class="headerlink" href="#qunfold.EnergyLoss" title="Permalink to this definition"></a></dt>
<dd><p>The loss function of EDx (Kawakubo et al., 2016) and EDy (Castaño et al., 2022).</p>
<p>This loss function represents the Energy Distance between two samples.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.HellingerSurrogateLoss">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">HellingerSurrogateLoss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_bins</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.HellingerSurrogateLoss" title="Permalink to this definition"></a></dt>
<dd><p>The loss function of HDx and HDy (González-Castro et al., 2013).</p>
<p>This loss function computes the average of the squared Hellinger distances between feature-wise (or class-wise) histograms. Note that the original HDx and HDy by González-Castro et al (2013) do not use the squared but the regular Hellinger distance. This approach is problematic because the regular distance is not always twice differentiable and, hence, complicates numerical optimizations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n_bins</strong> – The number of bins that is used in the feature transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.BlobelLoss">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">BlobelLoss</span></span><a class="headerlink" href="#qunfold.BlobelLoss" title="Permalink to this definition"></a></dt>
<dd><p>The loss function of RUN (Blobel, 1985).</p>
<p>This loss function models a likelihood function under the assumption of independent Poisson-distributed elements of <cite>q</cite> with Poisson rates <cite>M*p</cite>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.CombinedLoss">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">CombinedLoss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">losses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.CombinedLoss" title="Permalink to this definition"></a></dt>
<dd><p>The weighted sum of multiple losses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*losses</strong> – An arbitrary number of losses to be added together.</p></li>
<li><p><strong>weights</strong> (<em>optional</em>) – An array of weights which the losses are scaled.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">CombinedLoss</span></code> to create arbitrary, weighted sums of losses and regularizers.</p>
</div>
</section>
<section id="regularizers">
<h2>Regularizers<a class="headerlink" href="#regularizers" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="qunfold.TikhonovRegularized">
<span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">TikhonovRegularized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.TikhonovRegularized" title="Permalink to this definition"></a></dt>
<dd><p>Add TikhonovRegularization (Blobel, 1985) to any loss.</p>
<p>Calling this function is equivalent to calling</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CombinedLoss</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">TikhonovRegularization</span><span class="p">(),</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">tau</span><span class="p">])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loss</strong> – An instance from <cite>qunfold.losses</cite>.</p></li>
<li><p><strong>tau</strong> (<em>optional</em>) – The regularization strength. Defaults to 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of <cite>CombinedLoss</cite>.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The regularized loss of RUN (Blobel, 1985) is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">TikhonovRegularization</span><span class="p">(</span><span class="n">BlobelLoss</span><span class="p">(),</span> <span class="n">tau</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.TikhonovRegularization">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">TikhonovRegularization</span></span><a class="headerlink" href="#qunfold.TikhonovRegularization" title="Permalink to this definition"></a></dt>
<dd><p>Tikhonov regularization, as proposed by Blobel (1985).</p>
<p>This regularization promotes smooth solutions. This behavior is often required in ordinal quantification and in unfolding problems.</p>
</dd></dl>

</section>
<section id="feature-transformations">
<h2>Feature transformations<a class="headerlink" href="#feature-transformations" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.ClassTransformer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">ClassTransformer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_probabilistic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_classifier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.ClassTransformer" title="Permalink to this definition"></a></dt>
<dd><p>A classification-based feature transformation.</p>
<p>This transformation can either be probabilistic (using the posterior predictions of a classifier) or crisp (using the class predictions of a classifier). It is used in ACC, PACC, CC, PCC, and SLD.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> – A classifier that implements the API of scikit-learn.</p></li>
<li><p><strong>is_probabilistic</strong> (<em>optional</em>) – Whether probabilistic or crisp predictions of the <cite>classifier</cite> are used to transform the data. Defaults to <cite>False</cite>.</p></li>
<li><p><strong>fit_classifier</strong> (<em>optional</em>) – Whether to fit the <cite>classifier</cite> when this quantifier is fitted. Defaults to <cite>True</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.DistanceTransformer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">DistanceTransformer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preprocessor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.DistanceTransformer" title="Permalink to this definition"></a></dt>
<dd><p>A distance-based feature transformation, as it is used in <cite>EDx</cite> and <cite>EDy</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>metric</strong> (<em>optional</em>) – The metric with which the distance between data items is measured. Can take any value that is accepted by <cite>scipy.spatial.distance.cdist</cite>. Defaults to <cite>“euclidean”</cite>.</p></li>
<li><p><strong>preprocessor</strong> (<em>optional</em>) – Another <cite>AbstractTransformer</cite> that is called before this transformer. Defaults to <cite>None</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qunfold.HistogramTransformer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.</span></span><span class="sig-name descname"><span class="pre">HistogramTransformer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_bins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preprocessor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.HistogramTransformer" title="Permalink to this definition"></a></dt>
<dd><p>A histogram-based feature transformation, as it is used in <cite>HDx</cite> and <cite>HDy</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_bins</strong> – The number of bins in each feature.</p></li>
<li><p><strong>preprocessor</strong> (<em>optional</em>) – Another <cite>AbstractTransformer</cite> that is called before this transformer. Defaults to <cite>None</cite>.</p></li>
<li><p><strong>unit_scale</strong> (<em>optional</em>) – Whether or not to scale each output to a sum of one. A value of <cite>False</cite> indicates that the sum of each output is the number of features. Defaults to <cite>True</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Permalink to this heading"></a></h2>
<p>The following classes provide functionalities that go beyond the composition of quantification methods.</p>
<section id="quapy">
<h3>QuaPy<a class="headerlink" href="#quapy" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">qunfold.quapy</span></code> module allows you to wrap any quantification method for being used in <a class="reference external" href="https://github.com/HLT-ISTI/QuaPy">QuaPy</a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.quapy.QuaPyWrapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.quapy.</span></span><span class="sig-name descname"><span class="pre">QuaPyWrapper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">generic_method</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.quapy.QuaPyWrapper" title="Permalink to this definition"></a></dt>
<dd><p>A thin wrapper for using qunfold methods in QuaPy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>generic_method</strong> – A GenericMethod method to wrap.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Here, we wrap an instance of ACC to perform a grid search with QuaPy.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qunfold_method</span> <span class="o">=</span> <span class="n">QuaPyWrapper</span><span class="p">(</span><span class="n">ACC</span><span class="p">(</span><span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">obb_score</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quapy</span><span class="o">.</span><span class="n">model_selection</span><span class="o">.</span><span class="n">GridSearchQ</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">model</span> <span class="o">=</span> <span class="n">qunfold_method</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span> <span class="c1"># try both splitting criteria</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="s2">&quot;transformer__classifier__estimator__criterion&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;gini&quot;</span><span class="p">,</span> <span class="s2">&quot;entropy&quot;</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">},</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="c1"># ...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="cross-validated-training">
<h3>Cross-validated training<a class="headerlink" href="#cross-validated-training" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">qunfold.sklearn</span></code> module allows you to train classification-based quantification methods through cross-validation. Importing this module requires <a class="reference external" href="https://scikit-learn.org/stable/">scikit-learn</a> to be installed.</p>
<dl class="py class">
<dt class="sig sig-object py" id="qunfold.sklearn.CVClassifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qunfold.sklearn.</span></span><span class="sig-name descname"><span class="pre">CVClassifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_estimators</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qunfold.sklearn.CVClassifier" title="Permalink to this definition"></a></dt>
<dd><p>An ensemble of classifiers that are trained from cross-validation folds.</p>
<p>All objects of this type have a fixed attribute <cite>oob_score = True</cite> and, when trained, a fitted attribute <cite>self.oob_decision_function_</cite>, just like scikit-learn bagging classifiers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>estimator</strong> – A classifier that implements the API of scikit-learn.</p></li>
<li><p><strong>n_estimators</strong> (<em>optional</em>) – The number of stratified cross-validation folds. Defaults to <cite>5</cite>.</p></li>
<li><p><strong>random_state</strong> (<em>optional</em>) – The random state for stratification. Defaults to <cite>None</cite>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Here, we create an instance of ACC that trains a logistic regression classifier with 10 cross-validation folds.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ACC</span><span class="p">(</span><span class="n">CVClassifier</span><span class="p">(</span><span class="n">LogisticRegression</span><span class="p">(),</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>If you use a bagging classifier (like random forests) with <code class="docutils literal notranslate"><span class="pre">oob_score=True</span></code>, you do not need to use cross-validation. Instead, the quantification method is then trained on the out-of-bag predictions of the bagging classifier.</p>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Quickstart" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="developer-guide.html" class="btn btn-neutral float-right" title="Developer guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>